from tokenize import String
import frequency_domain
import argparse
import os
import logging

'''
This is a script which defines the CLI interface for the Frequency Domain Steganography class

There are two modes which can be used:
    Transmitter - This takes in two audio files as input. 
                    1. The base file is the source sound where the audio will be hidden
                    2. The secret message file is the message we want to obfuscate 
                        (i.e. the file to be hidden inside base file)

                    It outputs a new audio file containing the combined base + secret message

    Receiver - This takes in a single audio file as input, this is expected to be
                an audio file which has previously been generated by the Transmitter
                containing both the base audio data and the hidden message.

                It outputs a new audio file containing the recovered secret message


    For both modes there are a range of optional parameters (see the help information with -h) which 
    allow you to have finer grain control over the filtering & frequency modulation operations performed.
    These are not essential and if not provided will be set to reasonable defaults for hiding spoken word
    messages inside any kind of base signal.

    Note: The defaults of these optional parameters are different for the Transmitter / Receiver methods
    as they have been tuned to the specific use cases. 
    Frequency values are always specified in Hz

    Supplying the parameter -p or --save-plots will save (in the directory containing the output wav)
    plots of the various signals and their spectrums & spectrograms in png format and generated using
    pyplot

    Supplying the parameter --log allows setting the level of output from the application to STDOUT. 
    The possible options are: debug, info, warning, error, critical
'''

def transmitter(args):
    transmitter = frequency_domain.Transmitter(args.base_audio, args.secret_audio, lpf_cutoff=args.low_pass_frequency, bpf_lowcutoff=args.bandpass_lowcutoff_frequency, bpf_highcutoff=args.bandpass_highcutoff_frequency, order=args.filter_order)
    transmitter.perform(args.carrier_frequency, args.modulation_index)
    transmitter.write(args.output_path)

    if args.save_plots:
        output_directory = os.path.dirname(args.output_path)
        transmitter.save_plots(output_directory)


def receiver(args):
    receiver = frequency_domain.Receiver(args.input_audio, bpf_lowcutoff=args.bandpass_lowcutoff_frequency, bpf_highcutoff=args.bandpass_highcutoff_frequency, order=args.filter_order)
    receiver.perform(modulation_index=1, carrier_frequency = args.carrier_frequency)
    receiver.write(args.output_path)

    if args.save_plots:
        output_directory = os.path.dirname(args.output_path)
        receiver.save_plots(output_directory)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--save-plots", action='store_true')
    parser.add_argument("--log", default="INFO", help="Set the logging level to be used for stdout")
    subparsers = parser.add_subparsers(help='Sub command help')
    subparsers.required = True

    transmitter_parser = subparsers.add_parser("transmitter", help='transmitter help')
    transmitter_parser.add_argument("base_audio", help="The path to the base audio file")
    transmitter_parser.add_argument("secret_audio", help="The path to the secret audio file")
    transmitter_parser.add_argument("output_path", help="The path where the output audio will be saved")
    transmitter_parser.add_argument("-lpf", "--low-pass-frequency", type=float, default=14000.0, help="The cutoff frequency of the low pass filter to apply to the base signal (Hz)")
    transmitter_parser.add_argument("-bpfl", "--bandpass-lowcutoff-frequency", type=float, default=300.0, help="The low cutoff frequency of the bandpass filter to apply to the secret signal (Hz)")
    transmitter_parser.add_argument("-bpfh", "--bandpass-highcutoff-frequency", type=float, default=3300.0, help="The high cutoff frequency of the bandpass filter to apply to the secret signal (Hz)")
    transmitter_parser.add_argument("-o", "--filter-order", type=int, default=96, help="The order of the filters which are applied to the input signals")
    transmitter_parser.add_argument("-cf", "--carrier-frequency", type=float, default=20000.0, help="The center frequency used for frequency modulation of the secret signal (Hz)")
    transmitter_parser.add_argument("-mi", "--modulation-index", type=float, default=1.0, help="The modulation index to use for frequency modulation")
    transmitter_parser.set_defaults(func=transmitter)

    receiver_parser = subparsers.add_parser("receiver", help="receiver help")
    receiver_parser.add_argument("input_audio", help="The path to the audio with the hidden message inside")
    receiver_parser.add_argument("output_path", help="The path where the recovered message will be saved")
    receiver_parser.add_argument("-bpfl", "--bandpass-lowcutoff-frequency", type=float, default=18500.0, help="The low cutoff frequency of the bandpass filter to apply to the input signal (Hz)")
    receiver_parser.add_argument("-bpfh", "--bandpass-highcutoff-frequency", type=float, default=21500.0, help="The high cutoff frequency of the bandpass filter to apply to the input signal (Hz)")
    receiver_parser.add_argument("-o", "--filter-order", type=int, default=48, help="The order of the filters which are applied to the input signals")
    receiver_parser.add_argument("-cf", "--carrier-frequency", type=float, default=1500.0, help="The center frequency used for frequency demodulation to recover the secret signal (Hz)")
    receiver_parser.add_argument("-mi", "--modulation-index", type=float, default=1.0, help="The modulation index to use for frequency demodulation")
    receiver_parser.set_defaults(func=receiver)

    args = parser.parse_args()

    numeric_level = getattr(logging, args.log.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log)
    logging.basicConfig(level=numeric_level)

    args.func(args)
    